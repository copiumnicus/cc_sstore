# HOT CHEESE

## keeps your private keys warm and safe and still easily, but securely accessible

Hot cheese is a binary which keeps your keys encrypted and decrypts them on demand for each request. The decryption is authorized by touch-id on mac (right now only mac available). Hot cheese sends private keys over https. On top of that it encrypts the secret using Diffieâ€“Hellman key exchange to an ephemeral private/public key pair generated by the requesting server (to not leave private keys plain in memory when sending over https).

## Where is the master encryption key?

In key chain app on mac.

API:

- /generate/<name>
- /read/<name> (upon touch id verification + permission to access target decryption key in keychain, will return the relevant key)

## Backup

You need to backup your master encryption key, fortunately you just need to do it once. That is not the same for the private keys you generate. I recommend you sync the encrypted stores with rsync to some vm + store on usb.

## How is this secure

### Request flow

```rust
// over https
// requesting server generates a single use key pair and requests secret with name=`NAME_OF_SECRET`
// requesting server prints it's public key in logs as it requests. Hot cheese prints requesting server public key for additional verification before using touch id.
let (ephemeral_private, ephemeral_public) = generate_ephemeral_keypair();
send_to_server_and_request_secret(ephemeral_public, "NAME_OF_SECRET");

// Hot cheese:
let shared_secret = ecdh_compute_shared_secret(server_private_key, ephemeral_public);
let aes_key = hkdf(shared_secret);
let private_key = decrypt_with_user_authorization();
let encrypted_key = aes_gcm_encrypt(aes_key, private_key);
// It's not a vulnerability to receive a wrong private key in our usecases, you could pin the public key otherwise if you need to
send_to_client(encrypted_key, server_public_key, nonce);

// requesting server:
let shared_secret = ecdh_compute_shared_secret(ephemeral_private, server_public_key);
let aes_key = hkdf(shared_secret);
let decrypted_key = aes_gcm_decrypt(aes_key, encrypted_key, nonce);
```

### Key encryption in files

Uses eth-keystore implementation slightly changed to only allow scrypt as the derivation function.
